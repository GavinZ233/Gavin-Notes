哈希表：
哈希表意为散列表，重点在于散列方法。
散列方法可大致分为：
1、MOD（取余）
2、y=kx+c 乘以系数散列
3、key过长时，截取部分进行散列
4、平方取中值
还有许多方法，其核心思想为“散列方法在简单的前提下满足散列需求”

最简单的冲突解决方法是后移
也有便于理解的“拉链法”：
在冲突的地址加一个链表，记录地址传入的值

哈希表的散列方法与冲突解决方法不止于此，可以日后再尝试了解。


迭代器：
在集合类实现迭代器方法，对外而言可以不需要了解结构也能遍历。

实现方法是在集合内部加一个光标，每次遍历内容会像链表遍历一样next，当next为false时，即遍历结束。
迭代器遍历时，可以返回内容，光标记录当前位置，返回结束根据光标读取接下来的内容，每次重新遍历需要将光标重置。


迭代，多次循环，每次循环一个返回。下一个循环可以引用上一个循环的返回。
递归，就是深度优先结构，先到最大深度，然而返回上一层继续，直到根节点为止。
遍历，对数据中，同一个维度的多个元素，做相同操作。
广播，在两个数据中，拉伸低维的那个数据的维度，并过采样。使两者形状相同，元素能一一对应。


迭代流程：调用目标容器其中的GetEnumerator（）,获取迭代目标的IEnumerator,执行IEnumerator中的MoveNext（），当MoveNext（）返回为true是，就会得到Current。


unity协程计时器执行原理：
协程函数的yield retrun返回计时类。
计时类装入IEnumerator中，第一个IEnumerator在StartCoroutine（）执行时就MoveNext。
后续每帧验证IEnumerator新的节点是否可以MoveNext（即判断是否能够继续迭代），
可以迭代MoveNext()返回true，迭代器可以继续遍历，下一帧会继续MoveNext()。
直到MoveNext()返回为false时，发现无法迭代，即停止迭代。
其中，在每次MoveNext后，记录计时类中的时间，与当前时间对比，即可以达到计时的效果。
因为，迭代器不满足时间条件就无法MoveNext()，只有MoveNext()，协程函数中的方法体才会执行。
{
     方法体              //被调用时即执行
     yield return xx;//等待满足xx条件后，MoveNext
     方法体             //等待上一个yield return MoveNext之后，才能执行
     yield return yy;//等待满足条件后，再MoveNext

}