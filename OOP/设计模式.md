# 设计模式

## 设计原则：
单一职责：高内聚        
开闭原则：拓展开放，修改关闭        
依赖倒置：高层不依赖底层，依赖它的父类，即使需要替换底层的内容，也不影响高层        
里氏替换：子类可以替换父类      

## 1. 简单工厂：
根据不同需求创建不同产品类返回      
甲方有需求，找工厂（客户经理），工厂（客户经理）判断需求创建（写出方案）产品并返回给甲方        
自己之前做的chartmgr就是工厂模式        
## 2. 策略模式：      
根据不同需求，内部创建策略类并解决      
类似工厂模式，不过是将不同的算法封装了起来。适用同样结果但有不同处理方法的情况。        
此处也引出了抽象工厂与反射，与我之前的想法不谋而合      



## 3. 装饰模式：
装饰类需要继承核心类，通过利用多态，让新添加的装饰类继承核心类，新逻辑在核心类逻辑后面执行。        
比如：客户先后想要按钮点击后带一些特效再带额外的音效。可以创建特效类和音效类，继承btn类，两者保持btn中base的情况下，再执行自己的新逻辑。        
创建时根据先后顺序：音效类指向特效类，特效类指向btn类，此时的音效类就代替原有的btn类，执行时就是先btn逻辑再出特效再出音效了
## 4. 代理模式：
顾名思义，代替目标类执行目标类的任务。      
如数据代理，代理就会在访问时去远端get数据，或者本地读取     
大话书里提到代理类与目标类继承同一类，代理类就能直接替换目标类不用修改其他部分代码，完成狸猫换太子。        
>此处也体现出面向接口编程的灵活性        
## 5. 工厂模式：
简单工厂的工厂只有一个，而产品有多个。
工厂模式则是每个产品都对应一个工厂，一个工厂只负责一种产品。
这样就是相当于把简单工厂的工厂分辨逻辑交给外部调用者了。
解决了简单工厂违背开闭原则的问题
